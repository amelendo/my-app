import { useEffect, useRef, useState } from "react";
import mapboxgl from "mapbox-gl";
import "mapbox-gl/dist/mapbox-gl.css";
import { TrackPoint } from "@/utils/gpxParser";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Navigation } from "lucide-react";
import { toast } from "sonner";

interface MapViewProps {
  track: TrackPoint[];
  trackName: string;
}

const MapView = ({ track, trackName }: MapViewProps) => {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<mapboxgl.Map | null>(null);
  const userMarker = useRef<mapboxgl.Marker | null>(null);
  const watchId = useRef<number | null>(null);

  const [isTracking, setIsTracking] = useState(false);
  const [userPath, setUserPath] = useState<TrackPoint[]>([]);
  const [pace, setPace] = useState<string>("–:–"); // allure au km

  /* ---------------- MAP ---------------- */
  useEffect(() => {
    if (!mapContainer.current || track.length === 0) return;

    mapboxgl.accessToken =
      "pk.eyJ1IjoiYW1lbGVuZG83MyIsImEiOiJjbWdsZHliNTExMzh3Mmxxd2oxYzZ3aXQ1In0.Jj2bDeD2J_ZJ0xX2I2cynQ";

    map.current = new mapboxgl.Map({
      container: mapContainer.current,
      style: "mapbox://styles/mapbox/outdoors-v12",
      center: [track[0].lon, track[0].lat],
      zoom: 13,
    });

    map.current.addControl(new mapboxgl.NavigationControl(), "top-right");

    map.current.on("load", () => {
      if (!map.current) return;

      // GPX Track
      const coordinates = track.map((p) => [p.lon, p.lat]);
      map.current.addSource("route", {
        type: "geojson",
        data: { type: "Feature", geometry: { type: "LineString", coordinates } },
      });
      map.current.addLayer({
        id: "route",
        type: "line",
        source: "route",
        paint: { "line-color": "hsl(15, 85%, 55%)", "line-width": 4 },
      });

      // Bounds
      const bounds = coordinates.reduce(
        (b, c) => b.extend(c as [number, number]),
        new mapboxgl.LngLatBounds(coordinates[0] as [number, number], coordinates[0] as [number, number])
      );
      map.current.fitBounds(bounds, { padding: 50, duration: 0 });

      // User path (tracé en temps réel)
      map.current.addSource("userPath", {
        type: "geojson",
        data: { type: "Feature", geometry: { type: "LineString", coordinates: [] } },
      });
      map.current.addLayer({
        id: "userPathLine",
        type: "line",
        source: "userPath",
        paint: { "line-color": "hsl(215, 85%, 45%)", "line-width": 3, "line-dasharray": [2, 2] },
      });
    });

    return () => {
      if (watchId.current) navigator.geolocation.clearWatch(watchId.current);
      map.current?.remove();
    };
  }, [track]);

  /* ---------------- GPS & TRACKING ---------------- */
  const handlePosition = (pos: GeolocationPosition) => {
    const { latitude, longitude } = pos.coords;
    const time = pos.timestamp;

    if (!map.current) return;

    // Marqueur utilisateur
    if (!userMarker.current) {
      const el = document.createElement("div");
      el.style.width = "18px";
      el.style.height = "18px";
      el.style.borderRadius = "50%";
      el.style.background = "hsl(215, 85%, 45%)";
      el.style.border = "3px solid white";
      el.style.boxShadow = "0 0 8px hsl(215, 85%, 45%)";
      el.style.animation = "pulse 1s infinite";

      // Animation CSS pour pulser
      const styleSheet = document.styleSheets[0];
      styleSheet.insertRule(`
        @keyframes pulse {
          0% { transform: scale(1); opacity: 0.7; }
          50% { transform: scale(1.5); opacity: 0.4; }
          100% { transform: scale(1); opacity: 0.7; }
        }
      `);

      userMarker.current = new mapboxgl.Marker(el)
        .setLngLat([longitude, latitude])
        .addTo(map.current);
    } else {
      userMarker.current.setLngLat([longitude, latitude]);
    }

    // Centrer la vue
    map.current.jumpTo({ center: [longitude, latitude] });

    // Mise à jour du chemin
    setUserPath((prev) => {
      const newPath = [...prev, { lat: latitude, lon: longitude, time }];

      const coords = newPath.map((p) => [p.lon, p.lat]);
      const source = map.current?.getSource("userPath") as mapboxgl.GeoJSONSource;
      if (source) source.setData({ type: "Feature", geometry: { type: "LineString", coordinates: coords } });

      // Calcul allure
      if (newPath.length >= 2) {
        const last = newPath[newPath.length - 1];
        const prevPoint = newPath[newPath.length - 2];
        const dist = getDistanceKm(prevPoint, last);
        const timeDiff = (last.time! - prevPoint.time!) / 1000;
        const paceSecPerKm = dist > 0 ? timeDiff / dist : 0;
        setPace(formatPace(paceSecPerKm));
      }

      return newPath;
    });
  };

  const handleError = (err: GeolocationPositionError) => {
    if (err.code === err.TIMEOUT) toast.warning("Waiting for GPS signal…");
    else toast.error(err.message);
  };

  const startTracking = () => {
    if (!navigator.geolocation) return toast.error("Geolocation not supported");
    setIsTracking(true);
    watchId.current = navigator.geolocation.watchPosition(handlePosition, handleError, {
      enableHighAccuracy: true,
      timeout: 20000,
      maximumAge: 0,
    });
  };

  const stopTracking = () => {
    if (watchId.current) navigator.geolocation.clearWatch(watchId.current);
    watchId.current = null;
    setIsTracking(false);
  };

  /* ---------------- HELPERS ---------------- */
  function getDistanceKm(p1: TrackPoint, p2: TrackPoint) {
    const R = 6371;
    const φ1 = (p1.lat * Math.PI) / 180;
    const φ2 = (p2.lat * Math.PI) / 180;
    const Δφ = ((p2.lat - p1.lat) * Math.PI) / 180;
    const Δλ = ((p2.lon - p1.lon) * Math.PI) / 180;
    const a = Math.sin(Δφ / 2) ** 2 + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  function formatPace(secPerKm: number) {
    if (secPerKm <= 0) return "–:–";
    const m = Math.floor(secPerKm / 60);
    const s = Math.round(secPerKm % 60);
    return `${m}:${s.toString().padStart(2, "0")} / km`;
  }

  /* ---------------- UI ---------------- */
  return (
    <Card className="overflow-hidden">
      <div className="relative h-[600px]">
        <div ref={mapContainer} className="absolute inset-0" />

        <div className="absolute top-4 left-4 z-10">
          <Card className="p-3 bg-card/95">
            <h3 className="font-semibold text-sm mb-2">{trackName}</h3>
            <Button
              size="sm"
              onClick={isTracking ? stopTracking : startTracking}
              variant={isTracking ? "destructive" : "default"}
              className="w-full"
            >
              <Navigation className="h-4 w-4 mr-2" />
              {isTracking ? "Stop Tracking" : "Start Tracking"}
            </Button>

            {isTracking && (
              <div className="mt-3 text-sm">
                <p>Allure actuelle : <b>{pace}</b></p>
              </div>
            )}
          </Card>
        </div>
      </div>
    </Card>
  );
};

export default MapView;
